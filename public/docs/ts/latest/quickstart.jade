include ../../../_includes/_util-fns
:marked
  Let's start from zero and build a super simple Angular 2 application in TypeScript.
  我们来从零开始，用TypeScript搭建一个简单的Angular 2应用。
.callout.is-helpful
  header Don't want TypeScript?不想使用TypeScript？
  :marked
    Although we're getting started in TypeScript, you can also write Angular 2 apps
    in JavaScript and Dart by selecting either of those languages from the combo-box in the banner.
    尽管在这里我们使用TypeScript举例，你也可以在顶部的Banner中的选框里
    选择查看使用JavaScript或Dart搭建Angular 2 应用的教程。
.l-main-section
  :marked
    ## The shortest, quickest ...
       快速搭建...
    Let's put something on the screen in Angular 2 as quickly as we can.

    我们可以使用最快的方法把angular 2显示出来。
  .l-sub-section
    :marked
      While we are about to describe steps to take on your development machine,
      you could take these same steps in an interactive, online coding environment
      such as [plunker](http://plnkr.co/ "Plunker"). You won't have to
      install a static server to run the app there.

      也许我们即将介绍的安装安装步骤在您的开发机上没有相同的步骤，你可以选择类似相同的在线编码软件[plunker](http://plnkr.co/ "Plunker")
      这样可以使你不用再次安装一个静态的服务器来运行应用。
      If you like what you see - and we think you will - you can repeat this
      exercise on your own machine later.

      如果你喜欢你所见到的，那么你可以在自己的计算机上安装软件来重复的进行这个练习。
  :marked
    **Create a new folder** to hold our application project, perhaps like this:

    **新建文件夹**用来保存我们的应用程序项目,一般是像这样：
    ```
    mkdir angular2-quickstart
    cd    angular2-quickstart
    ```
.l-main-section
  :marked
    ## Our first Angular component 创建第一个Angular应用
    **Add a new file** called **`app.ts`** and paste the following lines:
    **新建一个文件**我们把它命名为**`app.ts`**并黏贴以下代码:
  +makeExample('quickstart/ts/src/app/app.ts', null, 'app.ts')
  :marked
    We've just defined an Angular 2 **component**,
    one of the most important Angular 2 features.
    Components are our primary means of creating application views
    and supporting them with application logic.

    我们刚刚定义了angular 2 中的 component,
    它是angular 2中重要的特性.
    是我们创建应用视图的主要手段，
    并支持处理应用程序逻辑。
    Ours is an empty, do-nothing class named `AppComponent`.
    It would expand with properties and application
    logic when we're ready to build a substantive application.

    我们定义个空的类将它命名为 `AppComponent`  .
    它将扩展属性和应用
    现在我们构建一个实质性的应用程序逻辑。
    Above the class we see the `@Component` decoration.
    上面的类中我们看到一个 `@Component` 的装饰.
  .l-sub-section
    :marked
      The `@` symbol before the method name identifies `Component` as a decoration.
      A "decoration" is a TypeScript language feature
      for creating metadata about the class. Angular finds this metadata
      in the transpiled JavaScript and responds appropriately.

      在方法名之前用 **@** 符号作为标识 **Component** 的装饰.
      **"decoration"** 是TypeScript语言中的一个特性.
      创建关于类的元素据.Angular找到这个元素据
      在transpiled JavaScript进行适当的响应.
  :marked
    `@Component` tells Angular that this class *is an Angular component*.
    The configuration object passed to the `@Component` method has two
    fields, a `selector` and a `template`.

    `@Component` 告诉Angular这个类是Angular中的component
    配置对象传递给`@Component`的方法有两种,
    一个是`selector` 和另一个 `template`.

    The `selector` specifies a CSS selector for a host HTML element named `my-app`.
    Angular creates and displays an instance of our `AppComponent`
    wherever it encounters a `my-app` element.

    `selector`指定CSS选择器来自于HTML元素中名叫 `my-app`.
    Angular创建在哪里遇到一个`my-app`元素将会对
    `AppComponent`进行实例化操作

    The `template` field is the component's companion template
    that tells Angular how to render a view.
    Our template is a single line of HTML announcing "My First Angular App".

    这个`template`键是组件的配套模板
    它告诉Angular应该如何渲染视图.
    这里的模板是一个HTML名叫"My First Angular App".

    The `bootstrap` method tells Angular to start the application with this
    component at the application root.
    We'd be correct to guess that someday our application will
    consist of more components arising in tree-like fashion from this root.

    这个`bootstrap`方法告诉Angular启动应用程序
    应用程序在这个目录的根
    我们的正确的猜测，有一天我们的应用程序会有很多的组件
    我们用树的形式将他们表现出来

    In the top line we imported the `Component` and `bootstrap` symbols
    from the Angular 2 library. That's the way we do things now.
    We no longer expect to find our code or any library code in a global namespace.
    We `import` exactly what we need, as we need it, from named file and library resources.

    我们将上面`Component` 和 `bootstrap`导入Angular 2 库中.
    这就是我们该做的事情.
    我们不再期望找到我们的代码或任何库代码的全局名称空间。

.l-main-section
  :marked
    ## Add `index.html`

    添加 `index.html`

    **Create** an `index.html` file.

    **创建** 一个 `index.html` 文件.

    **Paste** the following lines into it ... and we'll discuss them:

    **黏贴**下面的代码...我们来讨论:

  +makeExample('quickstart/ts/src/index.1.html', null, 'index.html')
  :marked
    We see three noteworthy sections of HTML:
    我们看到三个值得注意的HTML代码:
    1. We load JavaScript libraries from the web.
    Let's take them on faith without further discussion.

    1. 我们从网络上加载JavaScript库
    而我们没有把它的信息进行进一步的讨论

    2. We configure something called `System` and ask it to import the
    application file with our `AppComponent` that we just wrote.
    `System` is the module loader (from the `system.js` library),
    a tool that can `import` code;
    remember the `import` statement in our `AppComponent`?

    2.我们配置一个叫 `System` 的链将它导入我的应用程序文件`AppComponent` .
    `System`是一个系统模块加载程序(来自 `system.js` 库),
    一个能`import`的代码;
    记得`import` 声明在我们 `AppComponent` 中?

      We're also asking `system.js` to "transpile" (AKA "compile") our
      TypeScript source code into JavaScript ... right here in the browser.<br/><br/>

      我们还要求`system.js`中的"transpile" (又名 "compile")
      将我们的Typescript资源中的代码转化为JavaScript... 使它们可以在浏览器中运行

    3. We note the `<my-app>` tag in the `<body>`.
    That's the custom HTML element we identified in the `@Component` decoration
    adorning our `AppComponent` class.

    3.我们注意到 `<my-app>` 这个标签在`<body>`.
    这是我们定制的HTML中元素标识它来自于`@Component`装饰
    装饰我们 `AppComponent` 类.

.l-main-section
  :marked
    ## Run it!

       运行！

    We need a static file server to serve our application to the browser.

    我们需要一个静态文件服务器服务来应用到浏览器中.
  .l-sub-section
    :marked
      Don't have a static file server handy?  Let's install one of our favorites
      called [live-server](https://www.npmjs.com/package/live-server "Live-server")
      with the **npm package manager**.

      没有一个静态服务器方便吗？让我们来安装一个我们最爱的服务器之一

      [live-server](https://www.npmjs.com/package/live-server "Live-server")

      和**npm 包管理**.

      Don't have npm?

      没有npm?

      [Get it now](https://docs.npmjs.com/getting-started/installing-node "Installing Node.js and updating npm")
      because we're going to use it now and repeatedly throughout this documentation.
      [现在获取](https://docs.npmjs.com/getting-started/installing-node "Installing Node.js and updating npm")

      因为我们要反复的使用它

      Once you have `npm` installed, open a terminal window and enter

      一旦你安装了 `npm`, 打开一个终端窗口

    pre.prettyprint.lang-bash
      code npm install -g live-server
  :marked
    Open a terminal window and enter
    打开一个终端窗口进入
  pre.prettyprint.lang-bash
    code live-server
  :marked
    In a few moments, a browser tab should open and display
    几分钟后，一个浏览器选项卡打开并显示
  figure.image-display
    img(src='/resources/images/devguide/quickstart/my-first-app.png' alt="Output of quickstart app")
  :marked
    Congratulations!  We are in business.
    恭喜你！我们的程序运行了
  .alert.is-helpful
    :marked
      If you see `Loading...` displayed instead, see the
      [Browser ES6 support appendix](#es6support).

      如果你看到`Loading...`而不是显示的话，去看[浏览器 ES6 支持](#es6支持).
.l-main-section
  :marked
    ## What's wrong with this?
    ## 这又什么不好呢?
    We were up and running in a hurry and we could explore Angular
    in this manner for quite some time.
    我们很快的运行和我们以这种方式探索Angular很长的一段时间.
    For a number of reasons this isn't a good approach for building an application.
    由于一些原因这并不是构建应用的好办法。
    <!-- TODO The formatting here is a little weird. Should improve readability. -->
    * Transpiling TypeScript in the browser becomes tediously slow when our
    app grows beyond a few files. We certainly won't do that in production. We should learn to
    compile locally and push the generated JavaScript to the server. We'll need some tools for that.

    * 当我们的应用程序文件在不断的增长的时候，Transpiling TypeScript在浏览器中会变得繁琐，缓慢。

    * Downloading JavaScript libraries from the web is OK for demos but
    it slows our development. Every time our app reloads, it must refetch these libraries.
    Don't count on browser caching.
    Our debugging and live-reload techniques will bust the browser cache. Loading libraries
    from the web also prevents us from developing our application offline or where connectivity is
    poor. Let's learn to download the libraries to our machine and serve them locally.
    * 从网络上可以下载 JavaScript 库的样例，但是它会减缓我们的开发。
    我们不要指望浏览器的缓存，每次我们的程序重新加载的时候，它都必须重新加载库.
    我们使用debug和live-reload的技术将破坏浏览器的缓存.从网络上加载库也使的我们的应用程序
    在脱机和连接性较差的时候开发出现问题。
    * We want our development cycle to be as fast and friction-free as possible.
    When we change our code, we want to see the results in the browser immediately.
    We have tools and procedures for that.
    我们希望我们的开发周期尽可能的快和避免摩擦，当我们改变我们的代码的时候，我们要立即在浏览器中查看我们的结果.
    我们可以使用工具和程序.
.l-main-section
  :marked
    ## Upping our game
    ## 提高我们的开发效率
      Let's take a few more steps to put our development on a better foundation. We will
      让我们来使用一个更好的架构来增加我们的开发效率.我们将:
      1. Revise the application project structure for future growth
      1. 修改程序的目录结构来使用未来的发展
      1. Install a few tools and packages
      1. 安装工具和软件包
      1. Revise the **`index.html`** to use local library resources
      1. 修改 **`index.html`** 中的库使用本地资源库
      1. Compile the TypeScript locally and watch for changes
      1. 在本地编译TypeScript和观察它的变化
    Shut down the `live-server` running in the terminal window (Ctrl-C) and proceed as follows.
    关闭服务器的终端窗口(Ctrl-C)和运行如下：.
.l-main-section
  :marked
    ## Revise the application project structure
    ## 修改应用程序的目录结构
    At the moment we're dumping everything into the "angular2-quickstart" **root folder**.
    Not bad when there are only two files. Not good as our application evolves.
    Let's give our project a little structure.
    We'll add a sub-folder - `src` - to hold project source code and a sub-sub-folder - `src/app` -
    to hold the application source code.
    In OS/X and Linux:

    现在我们创建"angular2-quickstart"**根目录文件夹**.
    刚开始的时候它只有两个文件.随着我们的应用程序不断开发
    我们让我们的目录添加子文件夹- `src` -来存放项目资源代码和一个下一级文件夹- `src/app` -来存放应用程序代码
    在OS/X和Liunux:
  pre.prettyprint.lang-bash
    code mkdir -p src/app
  :marked
    In Windows:
    在Windows:
  pre.prettyprint.lang-bash
    code mkdir src\app
  :marked
    **Move `index.html`** into the **`src`** folder.
    **Move `app.ts`** into the **`src/app`** folder.
    Our project folders should look like this.

    **移动 `index.html`** 到 **`src`** 文件夹.
    **移动 `app.ts`** 到 **`src/app`** 文件夹.
    我们项目文件夹应该是这个样子.
    ```
    angular2-quickstart
    └── src
      ├── app
      │   └── app.ts
      └── index.html
    ```
.l-main-section
  :marked
    ## Install npm packages locally
    ## 在本地安装npm
    We'll replace the web-based scripts in our `index.html` with
    scripts resident on our local machine.
    We get those scripts by installing two runtime `npm` packages into our project.
    我们在我们的本地机器上取代WEB脚本，`index.html`中脚本链接使用本地的
    通过安装运行`npm`包到我们的项目中得到这些脚本
    >**angular2** - the Angular 2 library.
    >**angular2** - 这个Angular 2 库。

    >**systemjs** - an open-source library that provides module loading.
    >**systemjs** - 一个开源库，提供加载模块。
    We'll also install two development tools:
    我们还将继续安装两个开发工具：
    >**typescript** - the TypeScript compiler
    >**typescript** - TypeScript编译器
    >**[live-server](https://www.npmjs.com/package/live-server "Live-server")** - the static file server that reloads the browser when files change.
    >**[live-server](https://www.npmjs.com/package/live-server "Live-server")** - 静态文件和服务器文件改变时重新加载。
    We may have loaded it earlier. We're doing it again
    我们可以早点加载它。 我们在本地引入项目时
    locally in our project so we are no longer vulnerable to
    a global uninstall or version change.
    **Open** a terminal window at our application's **root folder**
    Enter these commands:
    将不再容易受到卸载或者版本变化。我们应用程序**根文件目录**打开一个终端窗口，输入以下命令:
    ```
    npm init -y
    npm i angular2@2.0.0-alpha.44 systemjs@0.19.2 --save --save-exact
    npm i typescript live-server --save-dev
    ```
    These commands both *install* the packages and *create* an npm `package.json` that will
    help us develop and maintain our application in the future.
    The essence of our `package.json` should look like this:
  +makeJson('quickstart/ts/package.json', {paths: 'name, version, dependencies, devDependencies'})
  :marked
    There is also a `scripts` section. **Find and replace** it with the following:
  +makeJson('quickstart/ts/package.json', {paths: 'scripts'})
  :marked
    We've just extended our project world with script commands
    that we'll be running very soon.
.l-main-section
  :marked
    ## Update `index.html`
    **Replace** the library scripts section with references to
    scripts in the packages we just installed.
  +makeExample('quickstart/ts/src/index.html', 'libraries')
  :marked
    **Update** the `System` configuration script as follows.
  +makeExample('quickstart/ts/src/index.html', 'systemjs')
  .l-sub-section
    :marked
      We won't be transpiling TypeScript in the browser anymore.
      We'll do that on our machine and ship the generated JavaScript
      files to the server.
      We have to re-configure `system.js` to expect JavaScript files
      with a `.js` extension by default.
      Someday we might add a `Foo` class to our application in a `foo.ts`
      file and import it like this
    pre.prettyprint.lang-bash
      code import {Foo} from './app/foo'
    :marked
      `system.js`will know to look for a file named `foo.js` in the `src/app` folder.
      That's exactly what we're doing in the last line. We're
      importing our main application file `app` (the generated `app.js` to be precise)
      from the `src/app/` folder (we moved it there, remember?)
  :marked
    Here's the final version
  +makeExample('quickstart/ts/src/index.html', null, 'index.html')
.l-main-section
  :marked
    ## Prepare for TypeScript Compilation
    ### Add the TypeScript configuration file
    We'll add a configuration file named **`tsconfig.json`**
    to tell the editor how to interpret our TypeScript code and
    to simplify the TypeScript compilation command that we'll run very soon.
    **Change to the `src` folder and create a `tsconfig.json`** file with the following content:
  +makeJson('quickstart/ts/src/tsconfig.json', null, 'tsconfig.json')
  .alert.is-helpful
    :marked
      See the [TypeScript configuration appendix](#tsconfig) to learn more about
      this file and these settings.
.l-main-section
  :marked
    ## Final structure
    Our final project folder structure should look like this:
    ```
    angular2-quickstart
    ├── node_modules
    ├── src
    │  ├── app
    │  │  └── app.ts
    │  ├── index.html
    │  └── tsconfig.json
    └── package.json
    ```
.l-main-section
  :marked
    ## Compile the TypeScript to JavaScript
    We no longer transpile TypeScript to JavaScript in the browser.
    We run the **T**ype**S**cript **C**ompiler (TSC) on our machine instead.
    Open a terminal window in the **root of the application folder** and enter:
  pre.prettyprint.lang-bash
    code npm run tsc
  :marked
    When it's done we should find the generated *app.js* file in the *src* folder and also an *app.map.js* file that
    helps debuggers navigate between the JavaScript and the TypeScript source.
    Our script set the compiler watch option (`-w`) so the
    compiler stays alive when it's finished.
    It watches for changes to our **`.ts`** files
    and recompiles them automatically.
    Leave this command running in the terminal window.
    You can stop it anytime with `Ctrl-C`.
.l-main-section
  :marked
    ## Run the app!
    Now we are ready to see our app in action.
    Open another terminal window in the **root of the application folder** and
    launch `live-server` again although this time we'll do it with
    one of our `npm` script commands:
  pre.prettyprint.lang-bash
    code npm start
  :marked
    **live-server** loads the browser for us, serves the HTML and JavaScript files,
    and displays our application message once more:
  figure.image-display
    img(src='/resources/images/devguide/quickstart/my-first-app.png' alt="Output of quickstart app")
  :marked
    ### Make some changes
    **`live-server`** detects changes to our files and refreshes the browser page for us automatically.
    Try changing the message to "My SECOND Angular 2 app".
    The TypeScript compiler in the first terminal window is watching our source code. It recompiles and produces
    the revised *app.js*.  The `live-server` sees that change and reloads the browser.
    Keep `live-server` running in this terminal window. You can stop it anytime with `Ctrl-C`.
.l-main-section
  :marked
    ## What have we done?
    Our first application doesn't do much. It's basically "Hello, World" for Angular 2.
    We kept it simple in our first pass: we wrote a little Angular component,
    we added some JavaScript libraries to `index.html`, and launched with a
    static file server. That's about all we'd expect to do for a "Hello, World" app.
    **We have greater ambitions.**
    We won't ask Angular to build "Hello, World".
    We are asking it to help us build sophisticated applications with sophisticated requirements.
    So we made some strategic technology investments to reach our larger goals
    * our application loads faster with libraries installed locally and
    we can develop offline if we wish.
    * we're pre-compiling our TypeScript.
    * we're running the compiler and live-server with commands that give us immediate feedback as we make changes.
    The good news is that the overhead of setup is (mostly) behind us.
    We're about to build a small application that demonstrates the great things
    we can build with Angular 2.
    <!--TODO: Join us on the [Tour of Heroes](./toh-pt1.html) -->
<!-- Move this to the Style Guide when we have one -->
.l-main-section
  :marked
    <a id="tsconfig"></a>
    ### Appendix: TypeScript configuration
    We added a TypeScript configuration file (`tsconfig.json`) to our project to
    guide the compiler as it generates JavaScript files.
    Get details about `tsconfig.json` from the official
    [TypeScript wiki](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json).
    We'd like a moment to discuss the `noImplicitAny` flag.
    TypeScript developers disagree about whether it should be `true` or `false`.
    There is no correct answer and we can change the flag later.
    But our choice now can make a difference in larger projects so it merits
    discussion.
    When the `noImplicitAny` flag is `false`,
    the compiler silently defaults the type of a variable to `any` if it cannot infer
    the type based on how the variable is used. That's what we mean by "implicitly `any`".
    When the `noImplicitAny` flag is `true` and the TypeScript compiler cannot infer
    the type, it still generates the JavaScript files but
    it also reports an error.
    For this project and the other examples in this Developer Guide
    we set the `noImplicitAny` flag to `false`.
    Developers who prefer stricter type checking should set the `noImplicitAny` flag to `true`.
    We can still set a variable's type to `any` if
    that seems like the best choice. We'd be doing so explicitly after
    giving the matter some thought.
    If we set the `noImplicitAny` flag to `true`, we may get implicit index errors as well.
    If we feel these are more annoying than helpful,
    we can suppress them with the following additional flag.
    ```
    "suppressImplicitAnyIndexErrors":true
    ```
.l-main-section
  :marked
    <a id="es6support"></a>
    ### Appendix: Browser ES6 support
    Angular 2 requires ES6 support, such as can be found in most modern
    browsers. For older browsers (including IE 11) you can use a shim to get
    the needed functionality.
    After creating `package.json` (halfway through the quickguide), run this
    command to add a shim to the project:
  code-example(language="sh" format=".").
    npm install es6-shim --save
  :marked
    Now you can load the shim in your `index.html` before the other scripts:
  code-example(language="html" format=".").
    &lt;script src=&quot;../node_modules/es6-shim/es6-shim.js&quot;&gt;&lt;/script&gt;
